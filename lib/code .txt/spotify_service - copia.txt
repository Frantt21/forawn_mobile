import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/spotify_track.dart';
import '../models/download_info.dart';

class SpotifyService {
  static const String _searchBaseUrl = 'https://api.dorratz.com/spotifysearch';
  static const String _downloadBaseUrl = 'https://api.dorratz.com/spotifydl';

  /// Search for songs on Spotify (robust parsing + logs)
  Future<List<SpotifyTrack>> searchSongs(String query) async {
    final encodedQuery = Uri.encodeComponent(query);
    final url = Uri.parse('$_searchBaseUrl?query=$encodedQuery');

    try {
      final response = await http.get(url).timeout(const Duration(seconds: 12));

      // Logs para depuraciÃ³n
      print('[SpotifyService] searchSongs status=${response.statusCode}');
      print('[SpotifyService] searchSongs body=${response.body}');

      if (response.statusCode != 200) {
        throw Exception('Error en la bÃºsqueda: ${response.statusCode}');
      }

      dynamic jsonResponse;
      try {
        jsonResponse = json.decode(response.body);
      } catch (e) {
        // Si la API devuelve un string que contiene JSON (ej: "\"[...json...]\"")
        final trimmed = response.body.trim();
        if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
            (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
          final unquoted = trimmed.substring(1, trimmed.length - 1);
          try {
            jsonResponse = json.decode(unquoted);
          } catch (e2) {
            throw Exception('Respuesta no JSON: ${response.body}');
          }
        } else {
          throw Exception('Respuesta no JSON: ${response.body}');
        }
      }

      // Si es lista en la raÃ­z
      if (jsonResponse is List) {
        return jsonResponse.map((e) {
          if (e is Map<String, dynamic>) return SpotifyTrack.fromJson(e);
          return SpotifyTrack.fromJson(Map<String, dynamic>.from(e));
        }).toList();
      }

      // Si es mapa, buscar claves comunes
      if (jsonResponse is Map<String, dynamic>) {
        final candidates = ['results', 'tracks', 'data', 'items', 'songs'];
        for (final key in candidates) {
          if (jsonResponse.containsKey(key)) {
            final node = jsonResponse[key];
            if (node is List) {
              return node.map((e) {
                if (e is Map<String, dynamic>) return SpotifyTrack.fromJson(e);
                return SpotifyTrack.fromJson(Map<String, dynamic>.from(e));
              }).toList();
            }
          }
        }

        // Buscar la primera entrada que sea lista
        for (final entry in jsonResponse.entries) {
          if (entry.value is List) {
            final list = entry.value as List;
            return list.map((e) {
              if (e is Map<String, dynamic>) return SpotifyTrack.fromJson(e);
              return SpotifyTrack.fromJson(Map<String, dynamic>.from(e));
            }).toList();
          }
        }
      }

      throw Exception('Formato de respuesta inesperado');
    } catch (e, st) {
      print('[SpotifyService] searchSongs error: $e');
      print(st);
      rethrow;
    }
  }

  /// Get download URL for a Spotify track
  Future<DownloadInfo> getDownloadUrl(String spotifyUrl) async {
    final encodedUrl = Uri.encodeComponent(spotifyUrl);
    final url = Uri.parse('$_downloadBaseUrl?url=$encodedUrl');

    try {
      final response = await http.get(url).timeout(const Duration(seconds: 15));
      print('[SpotifyService] getDownloadUrl status=${response.statusCode}');
      print('[SpotifyService] getDownloadUrl body=${response.body}');

      if (response.statusCode != 200) {
        throw Exception('Error al obtener enlace: ${response.statusCode}');
      }

      dynamic jsonResponse;
      try {
        jsonResponse = json.decode(response.body);
      } catch (e) {
        throw Exception('Respuesta no JSON al pedir enlace de descarga');
      }

      if (jsonResponse is Map<String, dynamic>) {
        return DownloadInfo.fromJson(jsonResponse);
      }

      throw Exception('Formato inesperado al obtener enlace de descarga');
    } catch (e, st) {
      print('[SpotifyService] getDownloadUrl error: $e');
      print(st);
      rethrow;
    }
  }
}